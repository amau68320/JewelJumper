% Copyright (C) 2019 BARBOTIN Nicolas
\documentclass[a4paper,12pt]{article}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[sfdefault]{roboto}
\usepackage{courier}
\usepackage{fullpage}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xcolor}
\usepackage{float}
\usepackage{titling}
\usepackage{tikz}
\usepackage{listings}
\usepackage{glslListings}
\usepackage{calc}
\usepackage[compact]{titlesec}
\usepackage{graphicx} %\usepackage{subfig} %%Subfigures inside a figure
%\usepackage{setspace}

%% Math Packages
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{stmaryrd}

%% Document properties
\title{IN55 -- Rapport de projet}
\author{A. Einholtz et N. Barbotin}

%% PDF Meta
\usepackage[pdftex,
            pdfauthor={\theauthor},
            pdftitle={\thetitle}]{hyperref}

%% Line Spacing
%\singlespacing        %% 1-spacing (default)
%\onehalfspacing       %% 1,5-spacing
%\doublespacing        %% 2-spacing

%% Custom Colors
\definecolor{dgray}{gray}{0.25}
\definecolor{dgreen}{rgb}{0,0.5,0}
\definecolor{preprocessor}{rgb}{0.5,0.25,0}
\definecolor{glslType}{rgb}{0.5,0,1}


%% Page style
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\fancyhead{}
\fancyfoot[L]{\fontsize{11pt}{11pt}\selectfont\textcolor{dgray}{\theauthor}}
\fancyfoot[C]{} %\fancyfoot[C]{\fontsize{11pt}{11pt}\selectfont\textcolor{dgray}{\thetitle}} % Broken by titlesec ?!
\fancyfoot[R]{\fontsize{11pt}{11pt}\selectfont\textcolor{dgray}{Page \thepage\ sur \pageref*{LastPage}}}

%% Custom Math Operators
\DeclareMathOperator{\sinc}{sinc}

%% Custom commands
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=0.25pt] (char)
            {\rule[-3pt]{0pt}{\dimexpr2ex}#1};}}

\newcommand{\svg}[2][0cm]{
    \begin{figure}[H]
        \centering
        \def\svgwidth{\columnwidth - #1}
        \input{#2.pdf_tex}
    \end{figure}
}

\newcommand{\shadersrc}[1]{
    \lstinputlisting[language=GLSL]{../shaders/#1}
}

\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

%% Language styles
\lstset{language=GLSL,
        basicstyle=\ttfamily,
        keywordstyle=[1]\color{glslType}\ttfamily,
        keywordstyle=[2]\color{blue}\ttfamily,
        keywordstyle=[3]\color{blue}\ttfamily,
        keywordstyle=[4]\color{preprocessor}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{dgreen}\ttfamily,
        showstringspaces=false,
        frame=single,
        rulecolor=\color{gray},
        aboveskip=8pt,
        belowskip=0pt,
        breaklines=true,
        postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DOCUMENT
\begin{document}
\setlength{\parindent}{0cm}
\setlength{\parskip}{8pt}

\begin{center}
    % Title
    \Huge\thetitle

    \vfill
    \includegraphics[width=15cm]{screenshot.jpg}
    \vfill
\end{center}

\newpage
\tableofcontents

\newpage
\part{Introduction}
\section{Présentation du projet}
Dans le cadre de l'UV IN55 lors du semestre de printemps 2019, nous avons été chargé de réaliser
un projet basé sur OpenGL. Le sujet que nous avons sélectionné visait à faire le rendu de pierres
précieuses en temps réel. Pour cela, nous avons utilisé C++ avec les bibliothèques GLFW pour la
gestion de la fenêtre et GLEW pour le chargement d'OpenGL. Les mathématiques et l'interface graphique
sont gérées par des bibliothèques maisons, soit MGPCL et AISO.

\section{Utilisation}
TODO: décrire comment utiliser le projet (contrôle caméra etc...)

\section{Distribution des tâches}
osef

\section{Choix techniques}
Deux effets principaux interviennent dans le visuel des pierres précieuses: la réflection et la réfraction.
Ces effets étant difficile à mettre en œuvre en temps réel (c'est-à-dire, sans raytracing), nous avons décidé
de se limiter à un seul et unique objet dans toute la scène: la pierre précieuse. Celle-ci est placée dans un
décor reposant sur une \emph{environment map}; il s'agît d'une texture qui considérée comme \og à l'infini \fg
\ par rapport à la caméra. Cela permet d'accélérer de manière importante le rendu et permet d'atteindre une
centaine d'images par seconde sur une Intel HD Graphics 620, toute en gardant une qualité décente.

En plus de la réflection et de la réfraction, nous avons décidé d'implémenter les effets suivants:
\begin{itemize}
    \item Pipeline \emph{High-Dynamic Range} (HDR), pour assurer la qualité des réflections
    \item Exposition automatique: contrôle automatiquement la luminosité de la scène de manière à percevoir un maximum de couleurs différentes
    \item Bloom: effet d'éblouissement lorsque la caméra est exposée à une lumière importante
    \item Lens flare: imitation des artéfacts visuels produit par les imperfections des lentilles, perçus généralement lorsque le soleil fait directement face à la caméra
    \item Fast Approximative Anti-aliasing (FXAA) pour réduire \og l'aliasing \fg
\end{itemize}

\part{Fonctionnement}
\section{Fonctionnement général}
Les diagrammes UML iront ici, décrire aussi comment la forme de la gemme est générée
\svg{UML}

\section{Pipeline de rendu}
Le rendu de la scène est réalisé avec la pipeline suivante:
\svg{PipelineDeRendu}

\section{Passe de rendu principale}
La passe de rendu principale est celle durant laquelle les éléments visuels principaux sont dessinés; c'est-à-dire
la \emph{skybox} et la gemme. Comme il s'agît d'une passe de rendu HDR, cette passe de rendu prends en compte
l'exposition déterminée par le système d'exposition automatique, décrit plus bas. Enfin, cette passe de rendu
génère en plus du color buffer habituel, un second buffer HDR qui sera plus tard utilisé pour le \emph{bloom}
(l'effet d'éblouissement). Ce buffer est princialement noir, sauf aux endroits où la couleur dépasse un
seuil de luminance définit par l'utilisateur. Dans ce cas, le buffer de bloom contient la même valeur que le color
buffer. Ceci se résume par le code GLSL suivant:

\begin{lstlisting}
float luma = dot(final, vec3(0.2126, 0.7152, 0.0722));

if(luma > u_BloomThreshold)
    out_Bloom = vec4(final, 1.0);
else
    out_Bloom = vec4(0.0, 0.0, 0.0, 1.0);
\end{lstlisting}

La \emph{skybox} est un simple cube texturé avec l'\emph{environment map} décrite plus haut. Normalement, les faces
de la skybox doivent être placées à une distance infinie de la caméra. Comme nous ne pouvons pas vraiment faire cela,
nous simulons cet effet en placant le centre du cube à la position de la caméra, et en désactivant l'écriture dans le buffer
de profondeur (\texttt{glDepthMask}). Ainsi, tout objet déssiné après la skybox, qu'il soit devant ou derrière
celle-ci, sera tout de même déssiné à l'écran. Puisque c'est elle qui émet la lumière de toute la scène, le dessin de
ce cube est fait sans aucun calcul d'illumination.

La gemme, en revanche, subit quelques calculs d'illumination. Les deux effets à prendre en compte sont (comme dit précédemment)
la réflexion et la réfraction:
\svg[8cm]{refraction}

On part du vectur de vue $\overrightarrow{V}$ (vecteur partant du centre de la caméra et pointant vers le fragment), du vecteur
normale $\overrightarrow{N}$ et de l'indice de réfraction $\eta_{gemme}$. On en déduit le vecteur réfléchi $\overrightarrow{R}$
et réfracté $\overrightarrow{R_2}$, avec lesquels on lit la cubemap pour trouver les couleurs correspondantes. Les deux couleurs
sont ensuite mixées ensemble selon le coefficient de fresnel. Celui-ci dépends de l'indice de réfraction et du produit scalaire
$\overrightarrow{L}\cdot\overrightarrow{H}$. Or, on constate dans notre cas que le vecteur de direction de la lumière $\overrightarrow{L}$
est égal à $-\overrightarrow{R}$ (puisque la lumière vient de l'environment map). On constate aussi que:
\[
    \overrightarrow{H} = \frac{\overrightarrow{V} + \overrightarrow{L}}{\norm{\overrightarrow{V} + \overrightarrow{L}}}
    = \frac{\overrightarrow{V} - \overrightarrow{R}}{\norm{\overrightarrow{V} - \overrightarrow{R}}}
    = \ldots = -\overrightarrow{N}
\]
Ce qui au final nous donne:
\[
    \overrightarrow{L}\cdot\overrightarrow{H} = (-\overrightarrow{R})\cdot(-\overrightarrow{N}) = \overrightarrow{R}\cdot\overrightarrow{N}
\]
Tout cela se traduit par le shader suivant:
\begin{lstlisting}
vec3 N  = normalize(f_Normal);
vec3 V  = normalize(f_WorldPos - u_CamPos);
vec3 R  = normalize(reflect(V, N));
vec3 R2 = normalize(refract(V, N, 1.0 / u_IOR));

float fresnel = computeFresnel(u_IOR, max(0.0, dot(R, N)));
vec3 diffuse  = texture(u_CubeMap, R2).rgb * f_Color.rgb;
vec3 specular = texture(u_CubeMap, R).rgb;
vec3 final    = mix(diffuse, specular, fresnel) * pow(2.0, u_Exposure);

out_Color = vec4(final, 1.0);
\end{lstlisting}

\section{Réfraction interne et passe de face arrière}
Le \emph{shading} présenté dans la section précédente est correct, mais présente un défaut important: la réfraction ne se
produit que sur la face avant. En réalité, le rayon réfracté $\overrightarrow{R_2}$ devrait continuer à l'intérieur de l'objet
avant de se \og heurter \fg\ à la face arrière, sur laquelle il est à nouveau réfléchi et réfracté. Le nouveau rayon réfléchi
risque de \og rebondir \fg\ encore quelques fois dans la pierre, et simuler cet effet serait difficile. Le nouveau rayon réfracté
en revanche sort de l'objet, et il suffit alors d'utiliser la cubemap pour trouver la bonne couleur à afficher.
\svg[6cm]{refr_int}

On cherche donc à calculer $\overrightarrow{R_2'}$. Pour cela, on réalise au préalable le rendu d'une texture de profondeur ainsi
que d'une texture de normale constitué des faces arrières (\texttt{glCullFace(GL\_FRONT)}) de la gemme. Ceci nous permettra d'obtenir
la profondeur (en espace écran) ainsi que la normale (en espace monde) de tout point sur l'écran. Le rendu de la gemme décrit précédemment
est ensuite modifié:
\begin{itemize}
    \item Passer $\overrightarrow{R_2}$ en espace écran
    \item Partir des coordonnées $\overrightarrow{P}$ du fragment en cours de calcul
    \item Ajouter $\overrightarrow{R_{2,ecran}}\times pas$ à $\overrightarrow{P}$
    \item Faire de même jusqu'à ce que $P_z \geq \mathcal{D}(P_x, P_y)$ ($\mathcal{D}$ étant la profondeur de face arrière, retrouvée à partir de la texture générée tout à l'heure)
    \item A cette étape, on dispose des coordonnées espace écran de l'intersection entre $\overrightarrow{R_2}$ et la face arrière
    \item Retrouver $\overrightarrow{N'} = -\overrightarrow{\mathcal{N}}(P_x, P_y)$ avec $\mathcal{N}$ la normale de face arrière
    \item Calculer $\overrightarrow{R_2'}$ avec $\overrightarrow{R_2}, \overrightarrow{N'}$ et l'indice de réfraction
\end{itemize}

\ \\
Reste à déterminer un pas convenable de manière à ne pas sauter trop de pixels (et perdre de la précision) et ne pas être
trop gourmand en ressources, mais le résultat est convaiquant:
\begin{figure}[H]
    \centering
    \includegraphics[width=14cm]{intref_cmp.jpg}
\end{figure}

\end{document}
